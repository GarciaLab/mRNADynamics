function [RawParticles,globalModelStruct] = track02TrainGHMM(...
          RawParticles, FrameInfo, retrack, displayFigures)
  
  % This script takes as input track fragments generated by naive GNN
  % matching and uses these fragments to train a simple model of particle
  % motion. Here I assume that measured particle movements positions are 
  % noisy representations of true underlying states. I thus use a simple
  % Hidden Markov Model to model their motion. Measurement error is taken
  % to be Gaussian. The HMM-related scripts are taken from a (very useful)
  % codebase for HMMs. 
  % See http://www.ai.mit.edu/~murphyk/Software/hmm.html for details. 

  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%% Define parameters
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  % Specify HMM model hyperparameters 
  NumCoeff = 1;          %Number of coefficients in a vector (always 1) 
  NumMixtures = 1;          %Number of distinct gaussian emission types for each state
  NumStates = 3;          %Number of motion states (this is an arbitrary but should be >=3 and <=10
%   pixelSize = FrameInfo(1).PixelSize;
%   zSize = FrameInfo(1).ZStep;
  CovarianceType = 'diag'; % assume no covariance between different state emissions
  maxIter = 500;
  
  % minimum # time points in trace fragment for inclusion
  minLen = 10; 
  % num channels
  NCh = length(RawParticles);
  % specify order of variables in HMM strtuctures
  varNameCell = {'xPos','yPos','zPosDetrended'};
  unitFactors = [1 1 1]; % (model seems to do best when things are in pixel units)
  
  
  for Channel = 1:NCh
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%% Generate list of suitably long tracks
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  

    % initialize data vectors
    dataCell = {};
    trackLenVec = [];
  
    for p = 1:length(RawParticles{Channel})
      Frames = RawParticles{Channel}(p).Frame;               
      dF = diff(Frames);
      % check for discontinuities
      if any(dF>1)
        error('Multi-frame jump detected. Issue with initial particle stitching')
      end        

      % record
      trackLenVec(p) = length(dF);
      for v = 1:length(varNameCell)
        dataCell{p,v} = unitFactors(v)*diff(RawParticles{Channel}(p).(varNameCell{v}));         
      end
    end
    longIDVec = find(trackLenVec>minLen);
    % If we have at least one sufficiently long fragment, then train global
    % parameters
    if ~isempty(longIDVec)
      % Find longest fragment to use for initialization
      [~, initID] = max(trackLenVec);

      % initial guess of parameters
      prior0 = normalise(rand(NumStates,1));
      transmat0 = mk_stochastic(rand(NumStates,NumStates));

      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      %%% Use all available data to infer global avg motion parameters
      %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
      globalModelStruct = struct;
      % loop through x,y, and z data
      for i = 1:size(dataCell,2)
        % initialize key inference params
        [mu0, Sigma0] = mixgauss_init(NumStates*NumMixtures, dataCell{initID,i}, CovarianceType);
        mu0 = reshape(mu0, [NumCoeff NumStates NumMixtures]);
        Sigma0 = reshape(Sigma0, [NumCoeff NumCoeff NumStates NumMixtures]);
        mixmat0 = mk_stochastic(rand(NumStates,NumMixtures));

        % conduct EM inference of HMM parameters
        [globalModelStruct(i).LL, globalModelStruct(i).Prior,globalModelStruct(i).Transmat, ...
          globalModelStruct(i).Mu, globalModelStruct(i).Sigma, globalModelStruct(i).Mixmat] = ...
            mhmm_em(dataCell(longIDVec,i), prior0, transmat0, mu0, Sigma0, mixmat0, ...
                                        'verbose', 0, 'max_iter', maxIter);

      end
    % otherwise supply generic parameters
    else
      for v = 1:length(varNameCell)
        % calculate basic drift stats
        meanDrift = mean([dataCell{:,v}]);
        stdDrift = std([dataCell{:,v}]);
        % generate hmm vars
        globalModelStruct(v).Prior = ones(1,NumStates)/NumStates;
        globalModelStruct(v).Mixmat = globalModelStruct(v).Prior; 
        globalModelStruct(v).Transmat = ones(NumStates,NumStates)./repelem(NumStates,NumStates)';
        globalModelStruct(v).Mu = [meanDrift-stdDrift meanDrift meanDrift+stdDrift];
        globalModelStruct(v).Sigma = repmat(stdDrift,1,1,3);
        globalModelStruct(v).LL = NaN;
      end
    end
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%% Re-Infer particle-specific transition matrices
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    iter = 1;
    f = waitbar(0,['Training motion model (channel ' num2str(Channel) ')']);
    for p = 1:length(RawParticles{Channel})
      waitbar(p/length(RawParticles{Channel}),f);
      % refit transition matrix if particle is long enough
      if ismember(p,longIDVec)
        hmmModel = struct;
        for i = 1:size(dataCell,2)           
          % conduct EM inference of HMM parameters
          [hmmModel(i).LL, hmmModel(i).Prior,hmmModel(i).Transmat, ...
            hmmModel(i).Mu, hmmModel(i).Sigma, hmmModel(i).Mixmat] = ...
              ... % initialize using global param values
              mhmm_em(dataCell{p,i}, globalModelStruct(i).Prior, globalModelStruct(i).Transmat, ...
              globalModelStruct(i).Mu, globalModelStruct(i).Sigma, globalModelStruct(i).Mixmat, ...
                'verbose', 0, 'max_iter', maxIter,'adj_mix',0,'adj_mu',0,'adj_sigma',0);                        
        end
        iter = iter + 1;
      % otherwise just use global paramters
      else
        hmmModel = globalModelStruct;
      end
      for v = 1:length(varNameCell)
        hmmModel(v).var = varNameCell{v};
      end
      RawParticles{Channel}(p).hmmModel = hmmModel;
    end
    close(f);
  end